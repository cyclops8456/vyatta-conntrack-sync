#!/usr/bin/perl
#
# Module: vyatta-conntrack-sync.pl
#
# **** License ****
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# This code was originally developed by Vyatta, Inc.
# Portions created by Vyatta are Copyright (C) 2010 Vyatta, Inc.
# All Rights Reserved.
#
# Author: Mohit Mehta
# Date: May 2010
# Description: Script to configure conntrackd
#
# **** End License ****
#

use Getopt::Long;

use lib '/opt/vyatta/share/perl5';
use Vyatta::Config;
use Vyatta::Misc;
use Vyatta::Interface;

use warnings;
use strict;

my $dbg = 'true';

my $daemon      = '/usr/sbin/conntrackd';
my $init_script = '/etc/init.d/conntrackd';
my $lock_file   = '/var/lock/conntrack.lock';
my $ctl_file    = '/var/run/conntrackd.ctl';
my $conf_file   = '/etc/conntrackd/conntrackd.conf';

my $general_section_start    = "General {\n";
my $sync_section_start       = "Sync {\n";
my $mode_section_start       = "\tMode FTFW {\n";
my $multicast_section_start  = "\tMulticast {\n";
my $filter_section_start     = "\tFilter From Kernelspace {\n";
my $addrignore_section_start = "\t\tAddress Ignore {\n";
my $section_end              = "}\n";

my $conntrack_sync_err = "conntrack-sync error:";

sub conntrackd_restart {
  system("$init_script restart >&/dev/null");
}

sub conntrackd_stop {
  system("$init_script stop >&/dev/null");
}

sub conf_file_header {
  my $output;
  my $date = `date`;
  chomp $date;
  $output = "#\n# autogenerated by vyatta-conntrack-sync.pl on $date\n#\n";
  return $output;
}

sub generate_conntrackd_config {

  my $intf_name = get_conntracksync_val( "returnValue", "interface" );
  my @intf_ip = Vyatta::Misc::getIP( $intf_name, '4' );
  my @iponly = split( '/', $intf_ip[0] );
  my @failover_mechanism =
    get_conntracksync_val( "listNodes", "failover-mechanism" );
  my $vrrp_sync_grp = get_conntracksync_val( "returnValue",
    "failover-mechanism $failover_mechanism[0] sync-group" );
  my $mcast_grp = get_conntracksync_val( "returnValue", "mcast-group" );

  my $conntrack_table_size = `cat /proc/sys/net/netfilter/nf_conntrack_max`;
  my $cache_hash_size      = `cat /sys/module/nf_conntrack/parameters/hashsize`;
  chomp $cache_hash_size;
  chomp $conntrack_table_size;
  my $cache_table_size = 2 * $conntrack_table_size;

  my $socket_mem =
    111616; # default value in bytes for net.core.wmem_max and net.core.rmem_max
  my $sync_queue_size =
    get_conntracksync_val( "returnValue", "sync-queue-size" );
  my $event_listen_queue_size =
    get_conntracksync_val( "returnValue", "event-listen-queue-size" );

  if ( $event_listen_queue_size >= $sync_queue_size ) {
    $socket_mem = $event_listen_queue_size;
  } else {
    $socket_mem = $sync_queue_size;
  }

  my $err = undef;
  $err = system(
"sysctl -w net.core.wmem_max=$socket_mem; sysctl -w net.core.rmem_max=$socket_mem"
  );
  if ( $err != 0 ) {
    print
      "$conntrack_sync_err unable to set net.core.wmem_max|net.core.rmem_max\n";
    return undef;
  }

  ## BEGIN CONFIG FILE GENERATION ##
  my $output = undef;
  $output = conf_file_header();

  # GENERATE SYNC SECTION
  $output .= "\n#\n# Synchronizer settings\n#\n";
  $output .= $sync_section_start;

  $output .= $mode_section_start;
  $output .= "\t$section_end";

  # mode section end

  $output .= $multicast_section_start;
  $output .= "\t\tIPv4_address $mcast_grp\n";
  $output .= "\t\tGroup 3780\n";
  $output .= "\t\tIPv4_interface $iponly[0]\n";
  $output .= "\t\tInterface $intf_name\n";
  $output .= "\t\tSndSocketBuffer $sync_queue_size\n";
  $output .= "\t\tRcvSocketBuffer $sync_queue_size\n";
  $output .= "\t\tChecksum on\n";
  $output .= "\t$section_end";

  # multicast section end

  $output .= "$section_end";

  # SYNC SECTION END

  # GENERATE GENERAL SECTION
  $output .= "\n#\n# General settings\n#\n";
  $output .= $general_section_start;
  $output .= "\tNice -20\n";
  $output .= "\tHashSize $cache_hash_size\n"
    ;    # this should be same as 'firewall conntrack-hash-size'
         #  i.e. /sys/module/nf_conntrack/parameters/hashsize
  $output .= "\tHashLimit $cache_table_size\n"
    ;    # this should be double of 'firewall conntrack-table-size'
         # i.e. /proc/sys/net/netfilter/nf_conntrack_max
  $output .= "\tLogFile on\n";                  # need to figure this one out
  $output .= "\tSyslog on\n";                   # need to figure this one out
  $output .= "\tLockFile $lock_file\n";
  $output .= "\tUNIX {\n";
  $output .= "\t\tPath $ctl_file\n";
  $output .= "\t\tBacklog 20\n";
  $output .= "\t}\n";
  $output .= "\tNetlinkBufferSize 2097152\n";
  $output .= "\tNetlinkBufferSizeMaxGrowth $event_listen_queue_size\n";
  $output .= "\tNetlinkOverrunResync Off\n";
  $output .= "\tNetlinkEventsReliable On\n";

  $output .= $filter_section_start;
  $output .= $addrignore_section_start;
  $output .= "\t\t\tIPv4_address 127.0.0.1\n";
  $output .= "\t\t\tIPv6_address ::1\n";
  $output .= "\t\t$section_end";

  # addrignore section end
  $output .= "\t$section_end";

  # filter section end

  $output .= "$section_end";

  # GENERAL SECTION END

  ## END CONFIG FILE GENERATION ##

  return $output;
}

sub get_conntracksync_val {
  my ( $value_func, $rel_path ) = @_;
  my $config = new Vyatta::Config;
  $config->setLevel('service conntrack-sync');
  return $config->$value_func("$rel_path");
}

sub validate_vyatta_conntrackd_config {
  my $err_string = undef;

  # make sure interface is defined
  my $intf_name = get_conntracksync_val( "returnValue", "interface" );
  if ( !defined $intf_name ) {
    $err_string = "$conntrack_sync_err interface not defined";
    return $err_string;
  }

  # also need to validate that interface exists on the system
  # and that it has an IP address assigned to it
  my $intf = new Vyatta::Interface($intf_name);
  if ($intf) {
    if ( !$intf->exists() ) {
      $err_string = "$conntrack_sync_err interface does not exist on system";
      return $err_string;
    }
    if ( scalar( $intf->address('4') ) == 0 ) {
      $err_string =
        "$conntrack_sync_err IP address not configured on interface";
      return $err_string;
    }
  } else {
    $err_string = "$conntrack_sync_err invalid interface";
    return $err_string;
  }

  # make sure failover mechanism is configured
  my @failover_mechanism =
    get_conntracksync_val( "listNodes", "failover-mechanism" );
  if ( scalar(@failover_mechanism) == 0 ) {
    $err_string = "$conntrack_sync_err failover mechanism not defined";
    return $err_string;
  }

  return $err_string;
}

sub conntrackd_write_file {
  my ($config) = @_;

  open( my $fh, '>', $conf_file ) || die "Couldn't open $conf_file - $!";
  print $fh $config;
  close $fh;
}

sub vyatta_enable_conntrackd {

  my $error = undef;

  # validate vyatta config
  $error = validate_vyatta_conntrackd_config();
  return ( $error, ) if defined $error;

  # generate conntrackd config
  my $config = generate_conntrackd_config();
  return ( 'Error generating daemon config file', ) if !defined $config;

  # write to $conf_file
  conntrackd_write_file($config);
  print "wrote the following generated conntrackd config file - \n$config\n"
    if $dbg eq 'true';

  # start conntrackd
  print "Starting conntrackd...\n";
  conntrackd_restart();
  return;

}

sub vyatta_disable_conntrackd {

  print "Stopping conntrackd...\n";
  conntrackd_stop();
  return;

}

#
# main
#

my ($action);

GetOptions( "action=s" => \$action, );

die "undefined action" if !defined $action;

my ( $error, $warning );

( $error, $warning ) = vyatta_enable_conntrackd()  if $action eq 'enable';
( $error, $warning ) = vyatta_disable_conntrackd() if $action eq 'disable';

if ( defined $warning ) {
  print "$warning\n";
}

if ( defined $error ) {
  print "$error\n";
  exit 1;
}

exit 0;

# end of file
